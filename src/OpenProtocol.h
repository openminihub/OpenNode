// **********************************************************************************
// OpenNode library for OpenMiniHub IoT
// **********************************************************************************
// Copyright Martins Ierags (2016), martins.ierags@gmail.com
// http://openminihub.com/
// **********************************************************************************
// License
// **********************************************************************************
// This program is free software; you can redistribute it 
// and/or modify it under the terms of the GNU General    
// Public License as published by the Free Software       
// Foundation; either version 3 of the License, or        
// (at your option) any later version.                    
//                                                        
// Licence can be viewed at                               
// http://www.gnu.org/licenses/gpl-3.0.txt
//
// Please maintain this license information along with authorship
// and copyright notices in any redistribution of this code
// **********************************************************************************
#ifndef OpenProtocol_h
#define OpenProtocol_h
#include "NodeType.h"

#ifndef NULL
  #define NULL (0) // Not defined in Arduino
#endif
#ifndef MAX_PAYLOAD_LEN
  #define MAX_PAYLOAD_LEN 61
#endif

class NodeContact;
class OpenNode;

typedef enum {
  kContactId = 0,
  kPacketType,    //1
  kPacketSubType, //2
  kPacketPayload  //3
} PacketBuffer_t;

//The message type defines the overall properties of a message
typedef enum {
  C_PRESENTATION  = 0,  //!< Sent by a node when they present attached sensors. This is usually done in presentation() at startup.
  C_SET           = 1,  //!< This message is sent from or to a sensor when a sensor value should be updated.
  C_REQ           = 2,  //!< Requests a variable value (usually from an actuator destined for controller).
  C_INTERNAL      = 3,  //!< Internal MySensors messages (also include common messages provided/generated by the library).
  C_STREAM        = 4   //!< For firmware and other larger chunks of data that need to be divided into pieces.
} OpenPacket_t;

class OpenProtocol
{
public:
  OpenProtocol();

  static unsigned char *packetData();
  static unsigned int packetLength();
  static unsigned char *nonceData() { return OpenProtocol::mNonceBuffer; };
  static bool packetAck();
  
  static void setPayloadValue(const char* payload);
  static void setPayloadSize(unsigned char size) { mPacketLength = size+kPacketPayload; }
  static void signPayload(const char* nonce);

  static void buildInternalPacket(ContactInternal_t contactInternal, const char *message);
  static void buildNonceRequestPacket();
  static void buildNoncePacket(unsigned long *message);
  static void buildPresentPacket(unsigned char contactId, ContactType_t contactType);

  static void buildPingPacket();
  static void buildContactValuePacket(NodeContact *contact);
  static void buildValuePacket(unsigned char contactId, ContactData_t contactData);
  static void buildContactListPacket(OpenNode *node);
  static unsigned char buildMessagePacket(char *inputString);

//private:
  static unsigned char *mPacketBuffer;
  static unsigned char mPacketLength;
  static unsigned char mPacketCounter;
  static unsigned char *mNonceBuffer;
  static bool mAck;
};

#endif // OpenProtocol_h
